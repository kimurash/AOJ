## 方針
1. 問題を解く．
2. 必要に応じてコメントを書き足す．
3. 考察を読んで覚えておくべき内容はこのファイルにまとめる．

## 3章 初等的整列
適切なアルゴリズムを選択に際して留意すること
1. 計算量と安定性
2. 入力データを保持する配列以外にメモリが必要か
3. 計算量に影響する入力データの特徴

|              |    計算量     | 安定性 |  (2)  |  (3)  |
| ------------ | :-----------: | :----: | :---: | :---: |
| 挿入ソート   |   $O(n^2)$    |  安定  | 不要  | 昇順  |
| バブルソート |   $O(n^2)$    |  安定  | 不要  | なし  |
| 選択ソート   |   $O(n^2)$    | 不安定 | 不要  | なし  |
| シェルソート | $O(n^{1.25})$ |  安定  | 不要  | 昇順  |

- 挿入ソート
    - 取り出した値よりも大きい要素のみを後方に移動するため安定
    - 最悪計算量となるのは入力が降順のとき
    - 入力が昇順のときは$O(n)$
- バブルソート
    - 隣同士のみを比較・交換するため安定
    - 隣同士との比較に等号を入れて`A[j] <= A[j-1]`としてしまうと
      安定でなくなる．
    - バブルソートの交換回数は**反転数**とも呼ばれ，
      列の乱れ具合を表す数値として知られる．
- 挿入ソート
    - 離れた要素を交換するため不安定
- シェルソート
  - ほぼ整列されたデータに対しては高速に動作するという
    挿入ソートの特徴を活かしたアルゴリズム．
  - 最後に$g = 1$として通常の挿入ソートを行うまでには，
    対象となるデータは凡そ整列されていると期待できる．

### 単純なアルゴリズムの比較
- 外側のループ内処理が$i$回行われると
    - バブルソートと選択ソート  
    小さいものから順に$i$個が求まる．
    - 挿入ソート  
    元の配列の先頭から$i$個がソートされる．
- `flag`を用いない単純なバブルソートと選択ソートはデータに依存しないが，  
  挿入ソートは昇順のデータに対して高速に動作する．

## 第4章 データ構造
### 標準ライブラリのデータ構造
### [`list`](https://programming-place.net/ppp/contents/cpp/library/006.html#iterator)
双方向連結リストを実現するコンテナ．

イテレータによってシーケンシャルアクセスできる．  
`[]`演算子によるランダムアクセスはできない．

`vector`とは異なり，要素の挿入と削除を$O(1)$で
高速に行うことができる．

- 宣言 `list<type> 変数名`
- 操作

| 関数名          | 機能                         | 計算量 |
| --------------- | ---------------------------- | ------ |
| `size()`        | リストの要素数               | $O(1)$ |
| `begin()`       | リストの先頭を指すイテレータ | $O(1)$ |
| `end()`         | リストの末尾を指すイテレータ | $O(1)$ |
| `push_front(x)` | 先頭への追加                 | $O(1)$ |
| `push_back(x)`  | 末尾への追加                 | $O(1)$ |
| `pop_front()`   | 先頭要素の削除               | $O(1)$ |
| `pop_back()`    | 末尾要素の削除               | $O(1)$ |
| `insert(p, x)`  | `p`の位置に要素`x`を挿入     | $O(1)$ |
| `erase(p)`      | `p`の位置の要素を削除        | $O(1)$ |
| `clear()`       | 全要素の削除                 | $O(N)$ |

- 現時点ではイテレータとはポインタのようなもの
  と考えておけばよい．
- `list.end()`によって得られるイテレータは，
  厳密には最後の要素の次を指す．

## 第5章 探索
標準データ型を使うと所望の結果が得られないことがあったので，
この章から`int`型も使っている．
- 要素数: `int`
- 要素: 標準データ型

### 標準ライブラリの探索
#### イテレータ
- コンテナの要素に対して反復処理を行うための
  オブジェクト
- 以下の基本演算を提供する．

| 演算子    | 機能                                 |
| --------- | ------------------------------------ |
| `++`      | 次の要素に進める                     |
| `==` `!=` | 同じ位置を指しているか               |
| `=`       | 左辺が指している位置に右辺の値を代入 |
| `*`       | 参照を外す                           |

- どの種類のコンテナに対しても同じ方法で走査できる．
- `begin()`は先頭を指すイテレータを返す．  
  `end()`は最後の要素の次位置を指すイテレータを返す．

## 第6章 再帰・分割統治法
### 全探索
### コッホ曲線

## 第7章 高等的整列
### マージソート
- $\log n$個の各階層で$O(n)$のマージが行われるため
  計算量は$O(n\log n)$
- 前半と後半のソート済み配列をマージする処理で，
  対象となる2つの要素が同じ場合は常に前半の要素を
  優先させれば安定にできる．
- 部分配列のために一時的なメモリ領域を必要とするため
  配列の扱いは得意ではない．
- 連結リストを使えばポインタの書き換えだけで要素を分割できる．

### クイックソート
- 分割統治法に基づくアルゴリズムであるが，
  統治にあたる明示的な処理はない．
- 離れた要素を交換するため不安定．
- マージソートにように追加のメモリ領域は必要としない．
- 右端の要素を枢軸とすると，昇順にソートされたデータ
  に対して常に最悪計算量がかかる．
- 右端，中央，右端の中央値をとるmedian-of-three法によって
  実質的に最悪のケースを回避できる．

### 分布数え上げソート
- 入力が0以上$k$以下の数列に対して$O(n + k)$で
  動作する安定なアルゴリズム．
- 入力の末尾から出力へと格納することで安定性を
  実現している．
- 入力の最大値に比例した出力用の記憶領域を別途必要とする．

### 標準ライブラリによる整列
- STLの`sort()`はクイックソートがベースになっている．  
- 安定なソートを行いたい場合はマージソートをベースとした
  `stable_sort()`を用いる．
- 配列の要素を整列したい場合は引数にポインタを指定する．

## 第8章 木
### 根付き木の表現
- 節点の数が変化しない根付き木は**左子右兄弟表現**によって
  表すことができる．
- 深さを再帰的に計算していくアルゴリズムは，
  各節点を一度ずつ訪問するので$O(n)$．

### 二分木の表現
- 高さを再帰的に計算していくアルゴリズムは，
  各節点を一度ずつ訪問するので$O(n)$．

### 木の巡回
- 木の各節点へ1度ずつ訪問するので$O(n)$
- 節点の数が膨大で木のバランスが悪いと，
  再帰が深くなり過ぎる可能性がある．

## 第9章 二分探索木
### 挿入
### 探索
### 削除
- 平均計算量: $O(\log n)$
- 最悪計算量: $O(n)$
- 二分探索木に対する操作が$O(\log n)$となるためには，
  常に木の高さをできるだけ低く維持する必要がある．  
  そのようなバランスのとれた木を**平衡二分木**と呼ぶ．

### 標準ライブラリによる集合の管理
- 集合を管理するSTLは2種類に分類される．
  - シーケンスコンテナ `vector` `list`  
    - 追加される要素の位置はその値に関係なく
      挿入した時点と場所に依存する．
  - 連想コンテナ `set` `map`
    - 要素が自動的にソートされて集合が管理される．
    - 常に二分探索が行える．

#### `set`
- 要素が値によってソートされている．
- 要素の重複は存在しない．

#### `map`
- 任意の型を添字とする連想配列として使用できる．
- キーの重複は許されない．

## 第10章 ヒープ
- 添字を1からにした方が都合がよい．

### 完全二分木
### 最大/最小ヒープ
- 計算量が$O(\log n)$の`downheap()`関数を
  $n/2$回呼び出すので$O(n\log n)$だと思われるが，
  実際に解析してみると$O(n)$で済むらしい．

### 優先度付きキュー
- `upheap()` `downheap()`ともに$O(\log n)$であるため，
  ヒープへの挿入と削除は$O(\log n)$である．

### 標準ライブラリによる優先度付きキュー
- ヒープで優先度付きキューを実現したい場合は
  標準ライブラリの`priority_queue`を利用できる．

## 第11章 動的計画法
### フィボナッチ数列
### 最長共通部分列
### 連鎖行列積
- 全体として3重のループ構造になっているため
  $O(n^3)$のアルゴリズム．

## 第12章 グラフ
### グラフの表記と用語
- グラフ$G = (V, E)$
  - $|V|$ : 頂点(vertex)の数
  - $|E|$ : 辺(edge)の数
- 辺$e = (u, v)$
- 重み$w(u, v)$
- $u$と$v$の間に辺があるとき**隣接している**．
- 隣接している頂点の列を**パス**と呼ぶ．
- 始点と終点が同じパスを**閉路**と呼ぶ．
- 頂点に繋がっている辺の数を**次数**と呼ぶ．
  - 入次数
  - 出次数
- グラフの任意に2頂点間にパスが存在すれば**連結**．
- 頂点集合$V$と辺集合$E$が共に内包されていれば**部分グラフ**．

### グラフの探索
- 全ての頂点を体系的に訪問すること．
- DFS: Depth First Search  
  行ける所までとことん行く．
- BFS: Breadth First Search  
  訪問済みと未訪問の境界を幅いっぱいに渡って
  拡張しながら探索する．

### グラフの表現
1. 隣接リスト
   - 辺の数に比例したメモリしか必要としない．
   - $u$から$v$に向かう辺のの有無を調べるために，
    $u$の出次数に比例した計算量がかかる．  
    通常はあまり問題にはならない．
  - 辺の削除を効率的に行うのが難しい．
2. 隣接行列  
  $$
  a_{ij} = \begin{cases}
    1 & \exists e = (i, j) \\
    0 & \nexists e = (i, j) \\
  \end{cases}
  $$
  - 辺の有無を$O(1)$で確認できる．
  - 辺の追加や削除が容易．
  - グラフが疎な場合はメモリが無駄．
  - 多辺グラフを表現できない．

### 深さ優先探索
### 幅優先探索
- 隣接行列を用いた場合
  - 各頂点について全ての頂点と隣接しているか調べるので
    $O(|V|^2)$のアルゴリズムとなる．
  - 頂点数が大きいグラフには適切でない．
- 隣接リストを用いた場合
  - (理論的には) 各頂点を1回ずつ訪問し，隣接リスト内の頂点を
    一度ずつ調べるので，$O(|V| + |E|)$
- 後の章で連結リストを用いた高速な実装方法を学習する．
- DFS/BFSで連結成分を求めることができる．  
  やることは画像工学の領域分割と同じ．

## 13章 重み付きグラフ
### 最小全域木
- **全域木(spanning tree)**
  - グラフ$G$の全ての頂点を含む$(V = V')$部分グラフ$G'$
  - 辺集合が木である．
- **最小全域木(shortest path spanning tree)**
  - 全域木の中で辺の重みの総和が最小のもの．

最小全域木を求めるアルゴリズム
- 優先度付きキューを使わない[**プリム法**](https://algo-logic.info/prim-mst/)
  - 隣接行列に対して実装しやすい．
  - ループ1回分の処理
    - 重みが最小の頂点を求める: $O(|V|)$
    - 頂点の追加による重みの最小値の更新 : $O(|V|)$
  - 頂点の数だけループするため$O(|V|^2)$．
  - 隣接リストを用い，最小の重みを管理するデータ構造として
    優先度付きキューを用いることで$O(|E|\log |V|)$の
    アルゴリズムにできる．

- 優先度付きキューを使う[**クラスカル法**](https://algo-logic.info/kruskal-mst/)
  - 隣接リストに対して実装しやすい．
  - アルゴリズムを理解していないため計算量は見積もれない．

### 最短経路問題(Shortest Path Problem)
- 与えられた頂点の組$(s, d)$を接続するパスのうち，
  辺の重みの総和が最小のものを求める問題．
- 始点$s$を根とし，$s$から全ての頂点への最短経路を包含する
  全域木$T$を**最短経路木(shortest path spanning tree)**
  と呼ぶ．

任意の頂点からの最短経路を求めるアルゴリズム
- **ダイクストラのアルゴリズム**  
  1. 隣接行列を用いた場合
  - ループ1回分の処理
    - 距離が最小の頂点$u$を求める : $O(|V|)$
    - 頂点$u$に隣接する頂点までの最短距離を更新 : $O(|V|)$
  - 頂点の数だけループするため$O(|V|^2)$．
  - 負の重みを含むグラフには適用できない．  
    - ベルマンフォードのアルゴリズム
    - ワーシャルフロイドのアルゴリズム
  
  2. 隣接リスト+優先度付きキューを連携させた場合
  - 頂点の数だけキューから頂点が取り出され，
    辺の数だけキューに挿入されるので$O((|V|+|E|)\log |V|)$

