## 14章 高度なデータ構造
- 章単体としては学習するつもりはなかったが，
  15章を読み解く上で必要となりそうだったので，
  `DisjoinSet`のみ学習する．

### 互いに素な集合
- クラス`DisjoinSet`は互いに素な集合(木)にデータを分類して
  管理するデータ構造を提供する．

- 以下の操作を具備する．
  - `make_set(x)` 要素が`x`のみの新しい集合を生成する．

  - `find_set(x)` 要素`x`が属する集合(木)の代表(根)を求める．
    - 以降に実行される`find_set(x)`のために**経路圧縮**を行う．
    - 経路圧縮における`rank`の更新は行わない．
      この理由は後ほど説明する．
  
  - `unite(x, y)` `x`を含む集合と`y`を含む集合を合併する．
    - 各ノード`x`を根としたときの高さ`rank[x]`を記録し，
      `rank`の小さい方の根が大きい方の根を指すようにする．
      こうすると新しい木が高くならない．
    - `rank`が等しい場合はどちらかに決定し，
      合併後の根の`rank`をインクリメントする．

  - `same(x, y)` `x`と`y`が同じ集合に属するか判定する．

- `union`と`same`のクエリを$O(\log |V|)$よりも速く処理できる．  
  具体的には，アッカーマンの逆関数を$\alpha$として$O(\alpha(|V|))$
  と表されるらしい．

- 経路圧縮において`rank`を更新しない理由  
  自分なりの見解を書き残しておく．そもそも`rank`を記録しておく
  動機は，合併後の木が高くならないようにすることである．しかし，
  `rank`を実際の高さよりも大きく記録した場合に，不必要に木が
  高くなってしまうケースが考えられるため，`rank`を更新しなくても
  よい理由は僕には分からない．

## 第15章 高度なグラフアリゴリズム
### トポロジカルソート
- グラフの全ての有向辺が左から右に向かうように
  全ての頂点を水平線上に並べる．
- 仕事を頂点，仕事の順序を有向辺と対応させると
  着手すべき順番で仕事を列挙できる．
- 本実装は隣接リストを用いているので$O(|V|+|E|)$．

### 最小全域木
- 14章で学習した`Union Find`木を利用した
  クラスカルのアルゴリズムで解く．
- 辺の整列に最も時間を要するため$O(|E|\log |E|)$．
- アルゴリズムの正当性を背理法を用いて示す．

記号の定義
- クラスカルのアルゴリズムで得られた全域木の辺集合を$K$とする．
- $K$の辺を選ばれた順に$\{e_1, e_2, \cdots, e_{|V|-1} \}$
  とする．
- $G$の最小全域木のうち$K$の辺を最も多く含むものの辺集合を
  $M_0$とし，$K \neq M_0$と仮定する．

$K \neq M_0$であるから，$K$には$M_0$に含まれない辺が存在する．
$\{e_1, e_2, \cdots, e_{|V|-1} \}$の中で$M_0$に含まれない
最初の辺を$e_k$とする．

ここで，$M_0$は全域木であるため，$M_0$に$e_k$を追加した
$M_0 \cup \{ e_k \}$には閉路ができる．$K$は木であるから，
この閉路を構成するの全ての辺が$K$に含まれることはない．
言い換えると，この閉路には$K$に含まれない辺が存在する．
この中から任意の辺を1つ選んで$f \in M_0$とする．

閉路を構成している辺の1つが$e_k$であるから，$e_k$を除いた
$\{e_1, e_2, \cdots, e_{k-1} \} \cup f \in M_0$は閉路を
含まない．$e_k$を選んだタイミングで代わりに$f$を選んでも
閉路は形成されなかったにも関わらず，$e_k$が選ばれたことに
なるため，$w(e_k) \leq w(f)$が成り立つ．

$M_1 = M_0 + \{ e_k \} \setminus \{ f \}$とすると，
$M_1$は連結で$|V|-1$本の辺を含む．$M_1$の重みの総和は，
$M_0\text{の総和} + w(e_k) - w(f)$となるが，
$w(e_k) = w(f)$でないと$M_0$が最小全域木でなくなり，
このとき$M_1$も最小全域木となる．

しかし，$M_1$は$M_0$よりも$K$の辺を1本多く含むため，
先の$M_0$の定義に反する．したがって，$K = M_0$となり，
$K$は最小全域木である．

## 第16章 計算幾何学

## 第17章 動的計画法
### コイン問題
- データ構造とアルゴリズムの過去問にも登場した
  動的計画法の典型的な問題．
- $m$枚のコインで$n$円支払うときの計算量は$O(nm)$．

### ナップサック問題
- $N$個の品物を容量が$W$のナップサックに詰め込む
  問題の計算量は$O(NW)$．

### 最長増加部分列
- 長さ$n$の数列の部分列の組合せは$2^n$通り存在するので，
  全探索は現実的でない．
- 動的計画法と二分探索を組み合わせて$O(n\log n)$で
  効率的に求めることができる．

## 第18章 整数論
### 素数判定
- 素朴な計算量の見積り
  - 2以外の偶数は素数でないことを利用すれば計算量は半減．
  - 約数は対になっているため，$n$の半分まで調べれば十分
    と分かればさらに半減．
 
  これらの工夫を考慮しても$O(N)$には変わりない．

- 合成数$n$は$p \leq \sqrt{n}$を満たす素因子$p$をもつ
  という性質を利用すると，2から$\sqrt{n}$までについて
  割り切れるか調べればよいため$O(\sqrt{n})$で判定できる．

- 複数を判定する場合は，**エラトステネスの篩**で
  あらかじめ素数表を用意した方が効率が良い場合がある．

- エラトステネスの篩は与えられた範囲内の全ての素数を
  列挙するアルゴリズムで，調べたい整数の最大値に比例した
  メモリ領域を必要とするが，計算量は$O(N\log \log N)$
  であることが知られている．

### 最大公約数
- 言わずと知れたユークリッドの互除法の出番．
- $a = bq + r$において$a \geq b$を仮定すると，
  $q \geq 1$となるため
  $$ a = bq + r \geq b + r $$
  さらに，$0 < r < b$であるから
  $$ a \geq b + r > r + r = 2r
    ~\Leftrightarrow~ \frac{a}{2} > r $$
  が成り立つ．

- 下記の表より，$b$は2回のステップで半分になることが分かる．

| 最大公約数       | 計算過程            | 不等式           |
| ---------------- | ------------------- | ---------------- |
| $\gcd(a, b)$     | $a =bq_1 + r_1$     | $r_1 \leq a / 2$ |
| $\gcd(b, r_1)$   | $b = r_1 q_2 + r_2$ | $r_2 \leq b / 2$ |
| $\gcd(r_1, r_2)$ |                     |                  |

- $\gcd(a, b)$の$b$が0になった時点でアルゴリズムが停止するため，
  総ループ回数はおよそ$2\log b$回である．
- 最大公約数を$g$として，
  - $a = ga'$
  - $b = gb'$
  
  と表すと，最小公倍数は$l = ga'b'$と求めることができる． 

## べき乗
- $n^m = (n^2)^{\frac{m}{2}}$を利用してべき数を
  半分にしていくため，再帰の深さは$O(\log n)$．

## 第19章 ヒューリスティック探索
### 8クイーン問題
- 素朴な計算量の見積り
  - 64マスから8マス選ぶ組み合わせは
    $_{64} \mathrm{C}_8 = 4,426,165,368$通り．
  - 1行に1つしか配置できないことを考えると
    $8^8 = 17,777,216$通り．
  - さらに，1列に1つしか配置できないことを
    加味すると$8! = 40,320$通り．

- **バックトラック**を利用すればさらに効率的に可能性を
  列挙できる．
  1. $r$個のクイーンが他のどのクイーンも襲撃しないように，
    上から$r$行に配置できた状態で，これらのどのQueenも
    襲撃しないように$r+1$行目のマスにQueenを配置する．
  2. $r+1$行目に配置できなければ$r$行目に戻り，$r$行目で
    襲撃されないマスの探索を続行する．$r$行目に配置できる
    マスがなくなれば，さらに$r-1$行目に戻る．

- グラフの深さ優先探索はバックトラックに基づいている．

### 8パズル問題
- パズル問題は状態遷移をくり返してゴールを探索する．
- 一度生成した状態を再度生成しないようにメモリに
  記録する必要がある．ハッシュや二分探索を応用すると
  効率的に管理でき，本実装では連想配列を用いた．

#### 深さ優先探索
1. それ以上状態遷移が不可能な場合
2. 一度生成した状態を生成してしまった場合
3. 問題の性質からそれ以上を探索しても明らかに無駄な場合

などは探索を打ち切ってバックトラックする．

- 問題の性質から深さを制限できれば高速化できる．
- 枝を刈らなければ無駄な計算量がかかってしまう．

などの特徴を持つ．

#### 幅優先探索
- 現在の状態から可能な全ての状態遷移を行い
  新しい状態を作る．
- 深さ優先探索よりも多くのメモリを必要とする．
  - 訪問待ちの状態を二重で記録する．
  - 訪問待ち(queue)に入れる状態が多い
